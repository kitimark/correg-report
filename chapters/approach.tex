\chapter{\ifproject%
\ifcpe โครงสร้างและขั้นตอนการทำงาน\else Project Structure and Methodology\fi
\else%
\ifcpe โครงสร้างของโครงงาน\else Project Structure\fi
\fi
}
\label{ch:approach}

ในบทนี้จะกล่าวถึงหลักการ และการออกแบบระบบ ซึ่งเราจะออกแบบระบบลงทะเบียนที่มีอยู่แล้วให้มีประสิทธิภาพมากขึ้น เราจะพัฒนานาในส่วนของ โครงสร้างพื้นฐาน ระบบการลงทะเบียน และ โปรแกรมส่วนของเซิฟเวอร์ของการลงทะเบียน ดังนี้

\makeatletter

\section {Infrastructure}
\label{sec:infra}

จากที่มาของโครงงานในบทที่~\ref{ch:intro} เราได้กล่าวถึงโครงสร้างพื้นฐานของเซิฟเวอร์ที่สำนักทะเบียน ดังรูป \ref{fig:reg_infra} ในปัจจุบันมีการแบ่ง VM \cite{vm} ได้ไว้อย่างไม่มีประสิทธิภาพ เนื่องจาก VM ชุดนี้ไม่ได้มีการใช้ system center orchestrator \cite{sco} ดังนั้น เราไม่สามารถทำการ deploy โปรแกรมให้เหมาะกับจำนวนผู้ใช้งานในระยะเวลาหนึ่ง และหรือถ้าโปรแกรมนั้นมีจำนวนผู้ใช้มากในระดับที่ VM ที่อยู่ไม่มีทรัพยากรเพียงพอที่จะรองรับ ตัวของโครงสร้างพื้นฐานนี้เองก็ไม่สามารถปรับการ deploy โปรแกรมนั้นๆ ไปที่ VM อื่นๆ ที่มีทรัพยากรเหลือที่ให้ใช้งาน ซึ่งเป็นข้อเสียหลักๆ ที่ทำให้ระบบล่มในเวลาต่อมา

\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[show background rectangle]
        \node[module ] (I1) {Docker VM};
        \node[module, right=of I1, xshift=-8mm] (I2) {Docker VM};
        \node[module, right=of I2, xshift=-8mm] (I3) {Docker VM};
        \node[ right=of I3, xshift=-8mm] (I5) {...};
        \node[module, right=of I5,  xshift=-8mm] (I4) {Docker VM};
    \end{tikzpicture} \\
    Kubernetes Cluster
    \end{center}
    \caption[Poem]{New Infrastructure with Kubernetes}
    \label{fig:new_infra}
\end{figure}

จากรูป \ref{fig:new_infra} เราได้วางแผนโครงสร้างพื้นฐานใหม่ โดยการนำ VM ทั้งหมดมารวมกันโดยทำให้อยู่ในรูปแบบ Kubernetes cluster ซึ่งสามารถทำให้ VM ต่างๆ สามารถทำงานร่วมกันได้ผ่าน Kubernetes control plane \cite{kubecomp} ดังนั้นเราสามารถ deploy ตัวของโปรแกรมต่างๆ ที่ต้องการให้ทำงาน พร้อมทั้งกำหนดการขยายตัวของจำนวน containers ได้จากการวัดการใช้งานโปรแกรมใน container นั้นๆ เช่น การใช้งานของหน่วยประมวลผล การใช้งานของหน่วยความจำชั่วคราว หรือจำนวนการร้องขอการใช้งานของตัวโปรแกรมนั้น เป็นต้น ที่เราสามารถกำหนดได้เองผ่าน Horizontal Pod Autoscaler \cite{kubehpa} ของ Kubernetes ได้ แล้วทางตัวของ Kubernetes จะทำการคำนวณและทำการ deploy ตัวของ container ให้โดยอัตโนมัติลงไปใน VM ที่ยังคงมีทรัพยากรเหลือใช้อยู่

\section {Enrollment system}

จากที่มาของโครงงานในบทที่~\ref{ch:intro} เราได้กล่าวว่า รูปแบบซอฟต์แวร์ (software design patterns \cite{sdp}) ที่ใช้ในโปรแกรมลงทะเบียนนั้นมีข้อจำกัดหลักคือการขยายตัวของ โปรแกรมนั้นทำได้แต่ไม่มีประสิทธิภาพ
%
\begin{figure}
    \centering
    \begin{center}
    Regist container \\
    \begin{tikzpicture}[show background rectangle]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{Enrollment system แบบที่ใช้งานอยู่}
    \label{fig:old_regist_system}
\end{figure}
%
รูป \ref{fig:old_regist_system} แสดงปัญหาหลักของข้อจำกัดดังกล่าว ซึ่งมี frontend layer และ server layer ที่เป็นโปรแกรมแบบ stateless ซึ่งเป็นโปรแกรมที่ไม่ได้การเก็บค่าต่างๆ มีหน้าที่ประมวลผลของการร้องขอ และติดต่อในส่วนของฐานข้อมูล ซึ่งทั้ง 2 layers นั้นอยู่ใน container เดียวกันทำให้การขยายตัวทุกครั้ง จำเป็นจะต้องสร้างทั้ง 2 layers นี้ไปพร้อมๆ กัน ดังรูป~\ref{fig:scaling_old_regist_system} ซึ่งบางครั้งระบบต้องการที่จะขยายตัวเนื่องจากหนึ่งใน layer ของระบบมีความต้องการใช้งานทรัพยากรที่มากขึ้น แต่ระบบไม่สามารถขยาย layer นั้นๆ เพียง layer เดียวได้เนื่องจากระบบต้องขยายทั้ง container (เมื่อ container นั้นเป็นโปรแกรมที่เป็น stateless \cite{slsf})
%
\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{การขยายตัวของ Enrollment system แบบที่ใช้งานอยู่ ต้องการขยายตัวในฝั่ง backend layer แต่จำเป็นต้องขยายตัวของ frontend layer ด้วย}
    \label{fig:scaling_old_regist_system}
\end{figure}
%
ดังนั้น หากมีการใช้งานฝั่ง server มากขึ้นและจำเป็นต้องทำให้ฝั่ง server ขยายตัว เราจะพบว่าฝั่ง frontend จะขยายตัวขึ้นตามจำนวน containers ที่เพิ่มขึ้นทั้งๆ ที่ frontend ไม่จำเป็นที่จะต้องขยายตัว

\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[ ]
        \node[module] (I1) {Frontend Layer};
        \node[fit=(I1), draw,inner sep=2mm, label={[xshift=2mm]Regist frontend container}] (fit1) {};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I2), draw,inner sep=2mm,label={[xshift=2mm]Regist backend container}] (fit2) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{Enrollment system ที่ออกแบบใหม่}
    \label{fig:new_regist_system}
\end{figure}
%
ดังนั้นเราควรที่จะแยกทั้ง 2 layers จากกันให้เป็นคนละ container ดังแสดงในรูป \ref{fig:new_regist_system} ซึ่งจะทำให้ Kubernetes สามารถเลือกขยายตัวบาง layer จากเงื่อนไขต่างๆ ที่กำหนด ดังที่ได้กล่าวไว้ข้างต้นในช่วงโครงสร้างพื้นฐาน (ตอนที่~\ref{sec:infra}) ส่งผลให้ระบบสามารถใช้ทรัพยากรของเซิฟเวอร์ได้อย่างมีประสิทธิภาพเพิ่มขึ้น
%
\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[ ]
        \node[module] (I1) {Frontend Layer};
        \node[fit=(I1), draw,inner sep=2mm, label={[xshift=2mm]Frontend container}] (fit1) {};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[module, left=of I2] (I3) {Backend Layer};
        \node[module, right=of I2] (I4) {Backend Layer};
        \node[fit=(I2), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit2) {};
        \node[fit=(I3), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit3) {};
        \node[fit=(I4), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit4) {};
        \foreach \i in {2,3,4}
            \draw[->] (I1)--(I\i);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{การขยายตัว Enrollment system ที่ออกแบบใหม่ ขยายตัวในฝั่ง backend layer จะไม่จำเป็นต้องขยายตัวในฝั่ง frontend layer}
    \label{fig:scaling_new_regist_system}
\end{figure}
%
รูป \ref{fig:scaling_new_regist_system} แสดงตัวอย่างเมื่อมีการใช้งานฝั่ง server มากขึ้นและจำเป็นต้องทำให้ฝั่ง server ขยายตัว ซึ่งจะเห็นว่าฝั่ง frontend นั้นไม่จำเป็นต้องขยายตัวตามไปด้วยอีกต่อไป

\subsection{Migrate to client-server pattern}

การที่จะแยกระหว่าง frontend และ backend ของระบบลงทะเบียนนั้นไม่ใช่เรื่องง่าย เนื่องจากระบบนั้นถูกพัฒนาจาก Laravel และใช้ Vue เป็นตัวช่วยในการพัฒนาในส่วนของ frontend ซึ่งใช้ Laravel mix เป็นตัวช่วยในการ่วมทำงานของ preprocessing ของ HTML ใน Laravel และเรียกใน bundle ของ Vue พร้อมๆกัน ซึ่งระบบนี้บางส่วนมีการตรวจสอบสิทธิ์ทั้งฝั่ง preprocessing ของ HTML และตรวจสอบสิทธิ์ผ่าน RESTful protocol เราจำเป็นที่ต้องย้ายการตรวจสอบสิทธิในฝั่งของ preprocessing ทั้งหมดไปเป็นตรวจสอบสิทธิผ่าน RESTful protocol เพื่อที่ให้ Vue และ Laravel นั้นมีการทำงานแยกออกจากกันอย่างชัดเจน

\section{Enrollment server}

จากที่มาของโครงงานในบทที่~\ref{ch:intro} เราได้กล่าวถืงประสิทธิภาพของการทำงานของโปรแกรมในฝั่งเซิฟเวอร์เอง พบว่ามีการจัดการข้อมูลบางส่วนภายในฐานข้อมูลอย่างไม่มีประสิทธิภาพ รวมทั้งมีข้อมูลที่ซ้ำซ้อนในหลายๆ ฐานข้อมูล ทำให้ มีโอกาสเกิดความขัดแย้งระหว่างข้อมูลใน 2 ฐานข้อมูลกันในภายหลัง และมีช่องโหว่อยู่ในการลงทะเบียนทำให้ระบบเกิดการเสียหายได้ ซึ่งเราจะกล่าวถึงการแก้ปัญหาในแต่ละวิธีในลำดับถัดไป

\section{Enrollment authentication}
จากระบบลงทะเบียน ได้มีการใช้งานระบบยืนยันตัวตนผ่าน CMU OAuth เพื่อระบุว่าผู้ใช้งานคนนั้คือใครหรือนักศึกษาคนไหน แต่ระบบของลงทะเบียนนั้นได้ใช้ Laravel Passport ที่เป็นเครื่องมือสำหรับการสร้างระบบ OAuth นำมาใช้งานกับระบบลงทะเบียน จากการพิจารณาความต้องการในส่วนนี้ เราพบว่าระบบไม่ได้ต้องการที่จะสร้าง OAuth แต่กำลังที่จะใช้งานระบบ CMU OAuth เท่านั้น ทำให้ระบบที่ถูกพัฒนาขึ้นมานั้นมีความซับซ้อนเพิ่มขึ้นโดยไม่มีความจำเป็น เราจึงแก้ปัญหาในส่วนนี้โดยทำการสร้างระบบยืนยันตัวตนระหว่าง CMU OAuth และทำการสร้างระบบตรวจสอบสิทธิ์ใหม่โดยใช้การสร้าง JWT สำหรับใช้แนบกับการทำงานในส่วนอื่นๆ

\subsection{Migration authentication}
จากการเปลี่ยนแปลงระบบการยืนยันตัวตนที่ได้กล่าวถึง นั้นเราพยายามรักษาโค้ดที่ถูกพัฒนาด้วย นักพัฒนาของสำนักทะเบียนเอง เพื่อรักษาการทำงานให้ทำงานทั้งหมด ให้ทำงานได้อย่างถูกต้อง โดยโปรเจคนี้ทำการสร้าง authentication object และ auard object ใหม่เข้าไปแทนที่ของ Laravel Passport authentication object และ guard object ของเดิมโดยพัฒนาตามฟังก์ชันที่ระบบลงทะเบียนนั้นเรียกใช้อยู่

\section{Performance issues}
ในระบบลงทะเบียน ในบางส่วนมีปัญหาทางด้านประสิทธิภาพและมีผลต่อการล่มของระบบโดยรวมตามมา ซี่งโปรเจคนี้จะพิจารณาในส่วนที่ถูกใช้งานเป็นจำนวนมาก หรือเป็นส่วนสำคัญที่มีการร้องขอบ่อยๆ

\section{Caching}

ปัญหาหลักของเซิฟเวอร์ล่ม คือ การที่ฐานข้อมูลทำงานหนักเกินไป โดยต้องทำงานทุกๆ ครั้งทีมีการร้องขอเข้ามา และต้องรองรับคำร้องขอข้อมูลจากโปรแกรมที่มีความซับซ้อนและมีจำนวนมากในแต่ละครั้ง ทำให้ฐานข้อมูลต้องรับภาระอย่างหนัก 
ทำให้มีโอกาสที่ฐานข้อมูลจะใช้เวลาในการประมวลผลนานเกินกว่าที่โปรแกรมฝั่งเซิฟเวอร์กำหนดไว้ (timeout) ในขณะเดียวกัน โปรแกรมเซิฟเวอร์ก็จำเป็นต้องรองรับการร้องขอที่เข้ามาเรื่อยๆ เนื่องจากต้องรอการตอบกลับจากของการร้องขอก่อนหน้านี้ จึงต้องเก็บการร้องขอที่ต้องรอไว้ใน buffer ซึ่งจะส่งผลให้หน่วยความจำชั่วคราวนั้นมีโอกาสเต็ม และส่งผลให้เซิฟเวอร์ปิดตัวในที่สุด

แนวทางการแก้ปัญหา เราพบว่าจริงๆ แล้ว เมื่อมีการร้องขอข้อมูล ไม่จำเป็นต้องส่งคำร้องขอไปยังฐานข้อมูลเพื่อดึงข้อมูลจากหน่วยความจำถาวรทุกๆ ครั้ง เนื่องจากข้อมูลบางส่วนมีการเปลี่ยนแปลงที่ไม่บ่อยนัก ดังนั้น เราสามารถนำข้อมูลเหล่านนี้ไปเก็บไว้ในหน่วยความจำชั่วคราว และดึงข้อมูลจากหน่วยความจำชั่วคราวในการร้องขอครั้งต่อไป โดยกำหนดเวลาที่จะมีชีวิตอยู่ (TTL \cite{ttl}) เพื่อให้มีการร้องขอข้อมูลใหม่ไปยังฐานข้อมูลเพื่อให้ ข้อมูลยังคงที่จะมีการนำสมัย (update) ตัวอย่างข้อมูลที่เหมาะกับการนำไปเก็บไปยังหน่วยความจำชั่วคราว (caching) คือ ข้อมูลวิชาเรียน และข้อมูลอาจารย์ผู้สอน ทำให้สามารถแบ่งเบาภาระที่จะเกิดขั้นในฐานข้อมูลได้ เนื่องจากการดึงข้อมูลจากหน่วยความจำชั่วคราวนั้นเร็วกว่า หน่วยความจำถาวร ซึ่งในทางปฏิบัติเราสามารถสร้างฐานข้อมูลบนหน่วยความจำสำรองได้โดยใช้ Redis \cite{redis}

\section{ช่องโหว่ที่เกิดขึ้น}

เราพบว่าช่องโหว่ที่เกิดขึ้นที่เห็นได้ชัด คือ API ของการร้องขอที่จะลงทะเบียนวิชาใดวิชาหนึ่ง ไม่ได้ถูกตรวจสอบความถูกต้องก่อนที่จะบันทึกลงไปในฐานข้อมูล ซึ่งทำให้ข้อมูลเกิดการผิดผลาดได้ ทั้งๆ ที่มีการตรวจสอบเกิดขึ้นแล้วในฝั่งของ frontend
ดังนั้น เราควรที่จะเพิ่มการตรวจสอบนี้ในระดับ backend ด้วย
