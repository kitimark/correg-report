\chapter{\ifproject%
\ifcpe โครงสร้างและขั้นตอนการทำงาน\else Project Structure and Methodology\fi
\else%
\ifcpe โครงสร้างของโครงงาน\else Project Structure\fi
\fi
}

ในบทนี้จะกล่าวถึงหลักการ และการออกแบบระบบ ซึ่งเราจะออกแบบระบบลงทะเบียนที่มีอยู่แล้วให้มีประสิทธิภาพมากขึ้น

\makeatletter

\section {Infrastructure}

จากที่มาของโครงงานในบทที่ 1 เราได้กล่าวถึงโครงสร้างพื้นฐานของเซิฟเวอร์ที่สำนักทะเบียน ดังรูป \ref{fig:reg_infra} ในปัจจุบันมีการแบ่ง VM \cite{vm} ได้ไว้อย่างไม่มีประสิทธิภาพ เนื่องจาก VM ชุดนี้ไม่ได้มีการใช้ System center orchestrator \cite{sco} ดังนั้น เราไม่สามารถทำการ deploy โปรแกรมให้เหมาะกับจำนวนผู้ใช้งานในระยะเวลาหนึ่ง และหรือถ้าโปรแกรมนั้นมีจำนวนผู้ใช้มากในระดับที่ VM ที่อยู่ไม่มีทรัพยากรเพืยงพอที่จะรองรับ ตัวของโครงสร้างพื้นฐานนี้เองก็ไม่สามารถปรับการ deploy โปรแกรมนั้นๆ ไปที่ VM อื่นๆ ที่มีทรัพยากรเหลือที่ให้ใช้งานซึ่งเป็นข้อเสียหลักๆ ที่ทำให้ระบบล่มในเวลาต่อมา

\begin{figure}[h]
    \centering
    \begin{center}
    \begin{tikzpicture}[show background rectangle]
        \node[module ] (I1) {Docker VM};
        \node[module, right=of I1, xshift=-8mm] (I2) {Docker VM};
        \node[module, right=of I2, xshift=-8mm] (I3) {Docker VM};
        \node[ right=of I3, xshift=-8mm] (I5) {...};
        \node[module, right=of I5,  xshift=-8mm] (I4) {Docker VM};
    \end{tikzpicture} \\
    Kubernetes Cluster
    \end{center}
    \caption[Poem]{New Infrastructure with Kubernetes}
    \label{fig:new_infra}
\end{figure}

จากรูป \ref{fig:new_infra} เราได้วางแผนโครงสร้างพื้นฐานใหม่ โดยการนำ VM ทั้งหมดมารวมกันโดยทำให้อยู่ในรูปแบบ Kubernetes cluster ซึ่งสามารถทำให้ VM ต่างๆ สามารถทำงานร่วมกันได้ผ่าน Kubernetes control plane \cite{kubecomp} ดังนั้นเราสามารถ deploy ตัวของโปรแกรมต่างๆ ที่ต้องการให้ทำงานพร้อมทั้งกำหนดการขยายตัวของจำนวน containers ได้จากการวัดการใช้่งานโปรแกรมใน container นั้นๆ เช่น การใช้งานของตัวประมวลผล, การใช้งานของหน่วยความจำชั่วคราว หรือจำนวนการร้องขอ การใช้งานของตัวโปรแกรมนั้น หรืออื่นๆ ที่เราสามารถกำหนดได้เองผ่าน Horizontal Pod Autoscaler \cite{kubehpa} ของ Kubernetes ได้ แล้วทางตัวของ Kubernetes จะทำการคำนวณและทำการ deploy ตัวของ container ให้อัตโนมัติลงไปใน VM ที่ยังคงมีทรัพยากรเหลือใช้อยู่

\section {Enrollment System}

จากที่มาของโครงงานในบทที่ 1 เราได้กล่าวถึง รูปแบบซอฟแวร์ (Software design pattern \cite{sdp}) ที่ใช้ในโปรแกรมลงทะเบียนนั้นมีข้อจำกัดหลักคือการขยายตัวของ โปรแกรมนั้นทำได้แต่ไม่มีประสิทธิภาพ

\begin{figure}[h]
    \centering
    \begin{center}
    Regist container \\
    \begin{tikzpicture}[show background rectangle]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{Enrollment system แบบที่ใช้งานอยู่}
    \label{fig:old_regist_system}
\end{figure}

จากรูป \ref{fig:old_regist_system} ปัญหาหลักคือ มี frontend layer และ server layer อยู่ในอยู่ใน container เดียวกันทำให้การขยายตัวทุกครั้ง จำเป็นจะต้องสร้างทั้ง 2 layer นี้ไปพร้อมๆ กัน ซึ่งบางครั้งระบบต้องการที่จะขยายตัวเนื่องจากหนึ่งใน layer ของระบบ มีความต้องการใช้งานทรัพยากรที่มากขึ้น แต่ระบบไม่สามารถขยาย layer นั้นๆเพียง layer เดียวกันได้เนื่องจากระบบต้องขยายทั้ง container (เมื่อ container นั้นเป็นโปรแกรมที่เป็น stateless \cite{slsf})

\begin{figure}[h]
    \centering
    \begin{center}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{การขยายตัวของ Enrollment system แบบที่ใช้งานอยู่ ต้องการขยายตัวในฝั่ง backend layer แต่จำเป็นต้องขยายตัวของ frontend layer ด้วย}
    \label{fig:scaling_old_regist_system}
\end{figure}

จากรูป \ref{fig:scaling_old_regist_system} ตัวอย่างการขยายตัวของระบบที่ใช้งานอยู่ในปัจจุบันเมื่อขยายตัวเมื่อมีการใช้งานของฝั่ง server มากขึ้นเราจะพบว่า frontend จะขยายตัวขึ้นตามจำนวน container ที่เพิ่มขึ้นทั้งๆ ที่ frontend ไม่ต้องการที่จะขยายตัว

\begin{figure}[h]
    \centering
    \begin{center}
    \begin{tikzpicture}[ ]
        \node[module] (I1) {Frontend Layer};
        \node[fit=(I1), draw,inner sep=2mm, label={[xshift=2mm]Regist frontend container}] (fit1) {};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I2), draw,inner sep=2mm,label={[xshift=2mm]Regist backend container}] (fit2) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{Enrollment system ที่ออกแบบใหม่}
    \label{fig:new_regist_system}
\end{figure}

ดังนั้นเราควรที่แยกทั้ง 2 layers จากรูป \ref{fig:new_regist_system} นั้นออกจากกันให้เป็นละ container จะทำให้ Kubernetes สามารถเลือกขยายตัวบาง layer จากเงื่อนไขต่างๆที่กำหนด ดังที่เรากล่าวไว้ข้างต้นในช่วงโครงสร้างพื้นฐานในบทที่ 3 นี้ ได้ทำใหใช้ทรัพยากรของเซิฟเวอร์ได้อย่างมีประสิทธิภาพเพิ่มขึ้น

\begin{figure}[h]
    \centering
    \begin{center}
    \begin{tikzpicture}[ ]
        \node[module] (I1) {Frontend Layer};
        \node[fit=(I1), draw,inner sep=2mm, label={[xshift=2mm]Frontend container}] (fit1) {};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[module, left=of I2] (I3) {Backend Layer};
        \node[module, right=of I2] (I4) {Backend Layer};
        \node[fit=(I2), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit2) {};
        \node[fit=(I3), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit3) {};
        \node[fit=(I4), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit4) {};
        \foreach \i in {2,3,4}
            \draw[->] (I1)--(I\i);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{การขยายตัว Enrollment system ที่ออกแบบใหม่ ขยายตัวในฝั่ง backend layer จะไม่จำเป็นต้องขยายตัวในฝั่ง frontend layer}
    \label{fig:scaling_new_regist_system}
\end{figure}

จากรูป \ref{fig:scaling_new_regist_system} ตัวอย่างการขยายตัวเมื่อมีการใช้งานของฝั่ง server มากขึ้นจะทำให้ backend ขยายตัว แต่ frontend ไม่จำเป็นต้องขยายตัว

\section{Enrollment Server}

จากที่มาของโครงงานในบทที่ 1 เราได้กล่าวถืง ประสิทธิภาพของการทำงานของโปรแกรมในฝั่งเซิฟเวอร์เอง พบว่ามีการติดต่อของ ฐานข้อมูลบางส่วนอย่างไม่มีประสิทธิภาพ รวมทั้งมีข้อมูลที่เก็บข้อมูลที่เหมือนกัน ในหลายๆ ฐานข้อมูลทำให้ มีโอกาศเกิดข้อมูลที่ขัดแย้งกันระหว่าง 2 ฐานกันในภายหลัง และ มีช่องโหว่อยู่ในการลงทะเบียนทำให้ระบบเกิดการเสียหายได้ ซึ่งเราจะกล่าวถึงการแก้ปัญหาในแต่ละวิธีในขั้นตอนต่อไป

\subsection{Data incosistency}

จากการวิเคราะห์ข้อมูลจากฐานข้อมูลที่เราได้มาบางส่วน พบว่ามีการซ้ำซ้อนอย่างชัดเจนในส่วนของวิชาลงทะเบียนที่มีอยู่ในทั้ง db\_center และ db\_regist ซึ่งเราสามารถนำข้อมูลไว้เพียงส่วนใดส่วนหนึ่งได้โดยที่เราจะนำมารวมกัน (aggregation \cite{aggregation}) ในระดับ application ของฝั่งเซิฟเวอร์ที่จะสามารถแก้ปัญหาข้ออยู่ในหลายๆ ฐานข้อมูลที่แยกกันได้

\subsection{Data Access Layer}

จากเราได้สัมภาษณ์ กับนักพัฒนาของสำนักทะเบียนเราพบว่า นักพัฒนานั้นได้พัฒนาโปรแกรมฝั่งเซิฟเวอร์นั้นเป็น การขอข้อมูลที่เป็น SQL statement โดยตรงผ่าน laravel อาจจะทำให้เข้าใจยากในการที่จะพัฒนาต่อ เราควรที่จะ layer ของการเข้าถึงข้อมูลโดยทำให้ข้อมูลของฐานข้อมูลอยู่ในรูปแบบ ORM \cite{orm}

\subsection{Web-base API}

เราสังเกตได้ว่า GraphQL API \cite{graphql} นั้นเหมาะสำหรับการทำ Web-base API ของระบบขนาดใหญ่ซึ่งสามารถ เพิ่มประสิทธิภาพได้เนื่องจาก GraphQL สามารถระบุได้ว่า ฝั่งของผู้ใช้ต้องการข้อมูลอะไรบ้าง ดังนั้นเราสามารถส่งข้อมูลกลับไปเพียงเฉพาะที่ต้องการเท่านั้น และเมื่อระบบที่มีขนาดใหญ่ขึ้นเรา ไม่จำเป็นต้องทำส่วน Web-base API เฉพาะของโปรแกรมนั้น แต่สามารถทำเป็นศูนย์กลางการเข้าถึงข้อมูล (Centralized API Gateway) แต่มีข้อมูลที่แยกออกจากกันอย่างชัดเจน (Decentralized Services) และยังมีความสามารถที่จะแก้ไขข้อมูลที่ซับซ้อนได้อย่างดี \cite{graphqlexec} ร่วมกับการใช้งานของ DataLoader ที่สามารถรวบรวมคำร้องขอของโปรแกรมของเซิฟเวอร์ เพื่อที่จะขอข้่อมูลจากฐานข้อมูลทำให้เราสามารถลดการขนส่งข้อมูล (traffic) ระหว่างกันได้

\section{Caching}

ปัญหาหลักของเซิฟเวอร์ล่ม คือ การที่ฐานข้อมูลทำงานหนักเกินไป และ ทำงานทุกๆ การร้องขอเข้ามา และจากโปรแกรม มีการส่งร้องขอไปยังฐานข้อมูลนั้นมีความซับซ้อนและมีจำนวนมาก ทำให้ฐานข้อมูลต้องรับภาระอย่างหนัก จึงทำให้มีโอกาสที่ฐานข้อมูลใช้เวลาในการประมวลผลที่นานจนทำให้เกิดการส่งข้อมูลที่ช้ากว่า โปรแกรมฝั่งเชิฟเวอร์กำหนด และอีกฝั่งหนึ่งคือ โปรแกรมเซิฟเวอร์จำเป็นต้องเก็บการร้องขอไปเรื่อยๆ เนื่องจากต้องรอการตอบกลับจากของการร้องขอก่อนหน้า จึงต้องเก็บการร้องขอที่ต้องรอไว้ใน buffer ซึ่งจะส่งผลให้หน่วยความจำชั่วคราวนั้นมีโอกาสเต็ม และส่งผลให้เซิฟเวอร์ปิดตัวในที่สุด

แนวทางการแก้ปัญหา เราพบว่าจริงๆ แล้ว เมื่อมีการร้องขอข้อมูลไปยังฐานข้อมูลนั้นไม่จำเป็นต้องส่งคำร้องขอไปยังฐานข้อมูลเพื่อดึงข้อมูลจากหน่วยความจำถาวรทุกๆ ครั้ง เนื่องจากข้อมูลบางข้อมูลมมีการเปลี่ยนแปลงที่ไม่บ่อย ดังนั้นเราสามารถนำข้อมูล เหล่านั้นไปเก็บเอาไว้ที่หน่วยความจำชั่วคราว และดึงข้อมูลจากหน่วยความจำชั่วคราวในการร้องขอต่อไป โดยกำหนดเวลาที่จะมีชีวิตอยู่ (TTL \cite{ttl}) เพื่อให้มีการร้องขอข้อมูลใหม่ไปยังฐานข้อมูลเพื่อให้ ข้อมูลยังคงที่จะมีการนำสมัย (update) ตัวอย่างข้อมูลที่เหมาะกับการนำไปเก็บไปยังหน่วยความจำชั่วคราว (caching) คือ ข้อมูลวิชาเรียน และข้อมูลอาจารย์ผู้สอน ทำให้สามารถแบ่งเบาภาระที่จะเกิดขั้นในฐานข้อมูลได้ เนื่องจากการดึงข้อมูลจากหน่วยความจำชั่วคราวนั้นเร็วกว่า หน่วยความจำถาวร ซึ่งในทางปฏิบัติเราสามารถสร้างฐานข้อมูลบนหน่วยความจำสำรองได้โดยใช้ Redis \cite{redis} มาใช้งานได้

\section{ช่องโหว่ที่เกิดขึ้น}

เราพบว่าช่องโหว่ที่เกิดขึ้นที่เห็นได้ชัด คือ API ขอการร้องขอที่จะลงทะเบียนวิชาใด วิชาหนึ่ง ไม่ได้ถูกตรวจสอบก่อนที่จะบันทึกลงไปในฐานข้อมูล ซึ่งทำให้ข้อมูลเกิดการผิดผลาดได้ ทั้งๆที่มีการเช็คเกิดขึ้นแล้วในฝั่งของ frontend เราควรที่จะเพิ่มการตรวจสอบนี้ในระดับ backend