\chapter{\ifproject%
\ifcpe โครงสร้างและขั้นตอนการทำงาน\else Project Structure and Methodology\fi
\else%
\ifcpe โครงสร้างของโครงงาน\else Project Structure\fi
\fi
}
\label{ch:approach}

ในบทนี้จะกล่าวถึงหลักการ และการออกแบบระบบ ซึ่งเราจะออกแบบระบบลงทะเบียนที่มีอยู่แล้วให้มีประสิทธิภาพมากขึ้น
\CIreply{พูดว่าจะลงละเอียดส่วนใดบ้าง}

\makeatletter

\section {Infrastructure}
\label{sec:infra}

จากที่มาของโครงงานในบทที่~\ref{ch:intro} เราได้กล่าวถึงโครงสร้างพื้นฐานของเซิฟเวอร์ที่สำนักทะเบียน ดังรูป \ref{fig:reg_infra} ในปัจจุบันมีการแบ่ง VM \cite{vm} ได้ไว้อย่างไม่มีประสิทธิภาพ เนื่องจาก VM ชุดนี้ไม่ได้มีการใช้ system center orchestrator \cite{sco} ดังนั้น เราไม่สามารถทำการ deploy โปรแกรมให้เหมาะกับจำนวนผู้ใช้งานในระยะเวลาหนึ่ง และหรือถ้าโปรแกรมนั้นมีจำนวนผู้ใช้มากในระดับที่ VM ที่อยู่ไม่มีทรัพยากรเพืยงพอที่จะรองรับ ตัวของโครงสร้างพื้นฐานนี้เองก็ไม่สามารถปรับการ deploy โปรแกรมนั้นๆ ไปที่ VM อื่นๆ ที่มีทรัพยากรเหลือที่ให้ใช้งาน ซึ่งเป็นข้อเสียหลักๆ ที่ทำให้ระบบล่มในเวลาต่อมา

\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[show background rectangle]
        \node[module ] (I1) {Docker VM};
        \node[module, right=of I1, xshift=-8mm] (I2) {Docker VM};
        \node[module, right=of I2, xshift=-8mm] (I3) {Docker VM};
        \node[ right=of I3, xshift=-8mm] (I5) {...};
        \node[module, right=of I5,  xshift=-8mm] (I4) {Docker VM};
    \end{tikzpicture} \\
    Kubernetes Cluster
    \end{center}
    \caption[Poem]{New Infrastructure with Kubernetes}
    \label{fig:new_infra}
\end{figure}

จากรูป \ref{fig:new_infra} เราได้วางแผนโครงสร้างพื้นฐานใหม่ โดยการนำ VM ทั้งหมดมารวมกันโดยทำให้อยู่ในรูปแบบ Kubernetes cluster ซึ่งสามารถทำให้ VM ต่างๆ สามารถทำงานร่วมกันได้ผ่าน Kubernetes control plane \cite{kubecomp} ดังนั้นเราสามารถ deploy ตัวของโปรแกรมต่างๆ ที่ต้องการให้ทำงาน พร้อมทั้งกำหนดการขยายตัวของจำนวน containers ได้จากการวัดการใช้งานโปรแกรมใน container นั้นๆ เช่น การใช้งานของหน่วยประมวลผล การใช้งานของหน่วยความจำชั่วคราว หรือจำนวนการร้องขอการใช้งานของตัวโปรแกรมนั้น เป็นต้น ที่เราสามารถกำหนดได้เองผ่าน Horizontal Pod Autoscaler \cite{kubehpa} ของ Kubernetes ได้ แล้วทางตัวของ Kubernetes จะทำการคำนวณและทำการ deploy ตัวของ container ให้โดยอัตโนมัติลงไปใน VM ที่ยังคงมีทรัพยากรเหลือใช้อยู่

\section {Enrollment system}

จากที่มาของโครงงานในบทที่~\ref{ch:intro} เราได้กล่าวว่า รูปแบบซอฟต์แวร์ (software design patterns \cite{sdp}) ที่ใช้ในโปรแกรมลงทะเบียนนั้นมีข้อจำกัดหลักคือการขยายตัวของ โปรแกรมนั้นทำได้แต่ไม่มีประสิทธิภาพ
%
\begin{figure}
    \centering
    \begin{center}
    Regist container \\
    \begin{tikzpicture}[show background rectangle]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{Enrollment system แบบที่ใช้งานอยู่}
    \label{fig:old_regist_system}
\end{figure}
%
รูป \ref{fig:old_regist_system} แสดงปัญหาหลักของข้อจำกัดดังกล่าว ซึ่งมี frontend layer และ server layer อยู่ในอยู่ใน container เดียวกันทำให้การขยายตัวทุกครั้ง จำเป็นจะต้องสร้างทั้ง 2 layers นี้ไปพร้อมๆ กัน ดังรูป~\ref{fig:scaling_old_regist_system} ซึ่งบางครั้งระบบต้องการที่จะขยายตัวเนื่องจากหนึ่งใน layer ของระบบมีความต้องการใช้งานทรัพยากรที่มากขึ้น แต่ระบบไม่สามารถขยาย layer นั้นๆ เพียง layer เดียวได้เนื่องจากระบบต้องขยายทั้ง container (เมื่อ container นั้นเป็นโปรแกรมที่เป็น stateless \cite{slsf})\CIreply{พูดถึง stateless ก่อนหน้านี้ นอกวงเล็บ}
%
\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \begin{tikzpicture}[]
        \node[module] (I1) {Frontend Layer};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I1) (I2), draw, inner sep=2mm,label={[xshift=2mm]Regist container}] (fit1) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{การขยายตัวของ Enrollment system แบบที่ใช้งานอยู่ ต้องการขยายตัวในฝั่ง backend layer แต่จำเป็นต้องขยายตัวของ frontend layer ด้วย}
    \label{fig:scaling_old_regist_system}
\end{figure}
%
ดังนั้น หากมีการใช้งานฝั่ง server มากขึ้นและจำเป็นต้องทำให้ฝั่ง server ขยายตัว เราจะพบว่าฝั่ง frontend จะขยายตัวขึ้นตามจำนวน containers ที่เพิ่มขึ้นทั้งๆ ที่ frontend ไม่จำเป็นที่จะต้องขยายตัว

\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[ ]
        \node[module] (I1) {Frontend Layer};
        \node[fit=(I1), draw,inner sep=2mm, label={[xshift=2mm]Regist frontend container}] (fit1) {};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[fit=(I2), draw,inner sep=2mm,label={[xshift=2mm]Regist backend container}] (fit2) {};
        \draw[<->] (I1)--(I2);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{Enrollment system ที่ออกแบบใหม่}
    \label{fig:new_regist_system}
\end{figure}
%
ดังนั้นเราควรที่จะแยกทั้ง 2 layers จากกันให้เป็นคนละ container ดังแสดงในรูป \ref{fig:new_regist_system} ซึ่งจะทำให้ Kubernetes สามารถเลือกขยายตัวบาง layer จากเงื่อนไขต่างๆ ที่กำหนด ดังที่ได้กล่าวไว้ข้างต้นในช่วงโครงสร้างพื้นฐาน (ตอนที่~\ref{sec:infra}) ส่งผลให้ระบบสามารถใช้ทรัพยากรของเซิฟเวอร์ได้อย่างมีประสิทธิภาพเพิ่มขึ้น
%
\begin{figure}
    \centering
    \begin{center}
    \begin{tikzpicture}[ ]
        \node[module] (I1) {Frontend Layer};
        \node[fit=(I1), draw,inner sep=2mm, label={[xshift=2mm]Frontend container}] (fit1) {};
        \node[module, below=of I1] (I2) {Backend Layer};
        \node[module, left=of I2] (I3) {Backend Layer};
        \node[module, right=of I2] (I4) {Backend Layer};
        \node[fit=(I2), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit2) {};
        \node[fit=(I3), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit3) {};
        \node[fit=(I4), draw,inner sep=2mm,label={[xshift=2mm]Backend container}] (fit4) {};
        \foreach \i in {2,3,4}
            \draw[->] (I1)--(I\i);
    \end{tikzpicture}
    \end{center}
    \caption[Poem]{การขยายตัว Enrollment system ที่ออกแบบใหม่ ขยายตัวในฝั่ง backend layer จะไม่จำเป็นต้องขยายตัวในฝั่ง frontend layer}
    \label{fig:scaling_new_regist_system}
\end{figure}
%
รูป \ref{fig:scaling_new_regist_system} แสดงตัวอย่างเมื่อมีการใช้งานฝั่ง server มากขึ้นและจำเป็นต้องทำให้ฝั่ง server ขยายตัว ซึ่งจะเห็นว่าฝั่ง frontend นั้นไม่จำเป็นต้องขยายตัวตามไปด้วยอีกต่อไป

\section{Enrollment server}

จากที่มาของโครงงานในบทที่~\ref{ch:intro} เราได้กล่าวถืงประสิทธิภาพของการทำงานของโปรแกรมในฝั่งเซิฟเวอร์เอง พบว่ามีการจัดการข้อมูลบางส่วนภายในฐานข้อมูลอย่างไม่มีประสิทธิภาพ รวมทั้งมีข้อมูลที่ซ้ำซ้อนในหลายๆ ฐานข้อมูล ทำให้ มีโอกาสเกิดความขัดแย้งระหว่างข้อมูลใน 2 ฐานข้อมูลกันในภายหลัง และมีช่องโหว่อยู่ในการลงทะเบียนทำให้ระบบเกิดการเสียหายได้ ซึ่งเราจะกล่าวถึงการแก้ปัญหาในแต่ละวิธีในลำดับถัดไป

\subsection{Data incosistency}

จากการวิเคราะห์ข้อมูลจากฐานข้อมูลที่เราได้มาบางส่วน พบว่ามีความซ้ำซ้อนอย่างชัดเจนในส่วนของวิชาลงทะเบียนที่มีอยู่ในทั้ง db\_center และ db\_regist ซึ่งเราสามารถนำข้อมูลไว้เพียงส่วนใดส่วนหนึ่งได้โดยที่เราจะนำมารวมกัน (aggregation \cite{aggregation}) ในระดับ application ของฝั่งเซิฟเวอร์ ทำให้แก้ไขปัญหาข้อมูลซ้ำซ้อนในหลายๆ ฐานข้อมูลได้

\subsection{Data Access Layer}

จากการสัมภาษณ์นักพัฒนาโปรแกรมของสำนักทะเบียนฯ เราพบว่า นักพัฒนานั้นได้พัฒนาโปรแกรมฝั่งเซิฟเวอร์นั้นเป็น การขอข้อมูลที่เป็น SQL statement โดยตรงผ่าน Laravel ซึ่งอาจจะทำให้ข้อมูลผลลัพธ์ที่ได้เป็นที่เข้าใจยากในการที่จะพัฒนาระบบต่อในอนาคต ดังนั้น เราควรที่จะเพิ่ม layer ของการเข้าถึงข้อมูลโดยทำให้ข้อมูลที่ถูกส่งมาจากฐานข้อมูลนั้นอยู่ในรูปแบบ object-relational mapping (ORM) \cite{orm}

\subsection{Web-based API}

เราสังเกตได้ว่า GraphQL API \cite{graphql} นั้นเหมาะสำหรับการทำ web-based API ของระบบขนาดใหญ่ ซึ่งสามารถ เพิ่มประสิทธิภาพได้เนื่องจาก GraphQL สามารถระบุได้ว่า ฝั่งของผู้ใช้ต้องการข้อมูลอะไรบ้าง ดังนั้นเราสามารถส่งข้อมูลกลับไปเพียงเฉพาะที่ต้องการเท่านั้น และเมื่อระบบมีขนาดใหญ่ขึ้น เราไม่จำเป็นต้องทำส่วนของ web-based API สำหรับโปรแกรมหนึ่งๆ โดยเฉพาะ แต่สามารถทำเป็นศูนย์กลางการเข้าถึงข้อมูล (centralized API gateway) โดยมีข้อมูลที่แยกออกจากกันอย่างชัดเจน (decentralized services) และยังมีความสามารถที่จะแก้ไขข้อมูลที่ซับซ้อนได้อย่างดี \cite{graphqlexec} ร่วมกับการใช้งานของ DataLoader ที่สามารถรวบรวมคำร้องขอของโปรแกรมของเซิฟเวอร์ เพื่อที่จะขอข้อมูลจากฐานข้อมูล ทำให้เราสามารถลดการขนส่งข้อมูล (traffic) ระหว่างกันได้

\section{Caching}

ปัญหาหลักของเซิฟเวอร์ล่ม คือ การที่ฐานข้อมูลทำงานหนักเกินไป โดยต้องทำงานทุกๆ ครั้งทีมีการร้องขอเข้ามา และต้องรองรับคำร้องขอข้อมูลจากโปรแกรมที่มีความซับซ้อนและมีจำนวนมากในแต่ละครั้ง ทำให้ฐานข้อมูลต้องรับภาระอย่างหนัก 
ทำให้มีโอกาสที่ฐานข้อมูลจะใช้เวลาในการประมวลผลนานเกินกว่าที่โปรแกรมฝั่งเซิฟเวอร์กำหนดไว้ (timeout) ในขณะเดียวกัน โปรแกรมเซิฟเวอร์ก็จำเป็นต้องรองรับการร้องขอที่เข้ามาเรื่อยๆ เนื่องจากต้องรอการตอบกลับจากของการร้องขอก่อนหน้านี้ จึงต้องเก็บการร้องขอที่ต้องรอไว้ใน buffer ซึ่งจะส่งผลให้หน่วยความจำชั่วคราวนั้นมีโอกาสเต็ม และส่งผลให้เซิฟเวอร์ปิดตัวในที่สุด

แนวทางการแก้ปัญหา เราพบว่าจริงๆ แล้ว เมื่อมีการร้องขอข้อมูล ไม่จำเป็นต้องส่งคำร้องขอไปยังฐานข้อมูลเพื่อดึงข้อมูลจากหน่วยความจำถาวรทุกๆ ครั้ง เนื่องจากข้อมูลบางส่วนมีการเปลี่ยนแปลงที่ไม่บ่อยนัก ดังนั้น เราสามารถนำข้อมูลเหล่านนี้ไปเก็บไว้ในหน่วยความจำชั่วคราว และดึงข้อมูลจากหน่วยความจำชั่วคราวในการร้องขอครั้งต่อไป โดยกำหนดเวลาที่จะมีชีวิตอยู่ (TTL \cite{ttl}) เพื่อให้มีการร้องขอข้อมูลใหม่ไปยังฐานข้อมูลเพื่อให้ ข้อมูลยังคงที่จะมีการนำสมัย (update) ตัวอย่างข้อมูลที่เหมาะกับการนำไปเก็บไปยังหน่วยความจำชั่วคราว (caching) คือ ข้อมูลวิชาเรียน และข้อมูลอาจารย์ผู้สอน ทำให้สามารถแบ่งเบาภาระที่จะเกิดขั้นในฐานข้อมูลได้ เนื่องจากการดึงข้อมูลจากหน่วยความจำชั่วคราวนั้นเร็วกว่า หน่วยความจำถาวร ซึ่งในทางปฏิบัติเราสามารถสร้างฐานข้อมูลบนหน่วยความจำสำรองได้โดยใช้ Redis \cite{redis}

\section{ช่องโหว่ที่เกิดขึ้น}

เราพบว่าช่องโหว่ที่เกิดขึ้นที่เห็นได้ชัด คือ API ของการร้องขอที่จะลงทะเบียนวิชาใดวิชาหนึ่ง ไม่ได้ถูกตรวจสอบความถูกต้องก่อนที่จะบันทึกลงไปในฐานข้อมูล ซึ่งทำให้ข้อมูลเกิดการผิดผลาดได้ ทั้งๆ ที่มีการตรวจสอบเกิดขึ้นแล้วในฝั่งของ frontend
ดังนั้น เราควรที่จะเพิ่มการตรวจสอบนี้ในระดับ backend ด้วย
